---
title: "The swdft Package"
author: "Lee Richardson"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Vignette Title}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>", 
  fig.width = 7, 
  fig.height = 5
)
```

The `swdft` package provides tools to analyze data with non-stationary periodic components. We named the package `swdft` because most functions use the Sliding Window Discrete Fourier Transform (SWDFT) as a building block. Quickly described, the SWDFT extends the discrete Fourier transform (DFT) from the frequency domain to the time-frequency domain. Whereas the DFT operates on the entire signal, the SWDFT takes a temporally ordered sequence of smaller DFTs on contiguous subsets of the signal. The SWDFT outputs a 2D complex array of coefficients, where the first dimension represents frequency, and the second dimension represents time. The SWDFT is widely used across science and engineering, so providing a straightforward implementation of the SWDFT and related functions fills a gap in the R landscape.

The functions we provide in the `swdft` package can be partitioned into three groups:

1. **The SWDFT**. Implements the SWDFT and provides tools to visualize the output. 
2. **Cosine regression**. Fits cosine functions to data using least squares. 
3. **Complex demodulation**. Fits cosine functions with time-varying parameters using _complex demodulation_. 

This vignette walks through the main functionality of each group. Before working through the examples, make sure you have the package loaded into memory.  

```{r, include=FALSE}
devtools::load_all("/home/lee/Dropbox/swdft/r/swdft")
```

```{r, eval=FALSE}
library(swdft)
```

## The SWDFT
The sliding window DFT (SWDFT) is useful for signals with non-stationary periodic components. So, to demonstrate the functionality of the `swdft` package, we use "local cosine signals" for data. A local cosine signal is simply a cosine function multiplied by an indicator, where the indicator function is only nonzero for a contiguous subset of the signal. Formally, a length $N$ local cosine signal is defined by 

$$
\begin{eqnarray}
  y_t &=& A \cos(2 \pi f t + \phi) \cdot \mathbb{1}_{S, S+L-1}(t), \nonumber \\
  t &=& 0, 1, \ldots, N - 1.
\end{eqnarray}
$$

The parameters of a local cosine signal are:

- A: Amplitude of the cosine function 
- f: Frequency of the cosine function 
- $\phi$: Phase of the cosine function 
- $S$: Start of the local cosine signal 
- $L$: Length of the local cosine signal 

You can generate a local cosine signal with the `?swdft::local_signal` function. In this example, we also add a small Gaussian noise factor:

```{r}
## Generate a local periodic signal + Gaussian noise 
set.seed(999)
signal_length <- 96
freq <- 3 / 32
amplitude <- 1
phase <- 0
sigma <- .3
periodic_start <- 20
periodic_length <- 50
signal <- swdft::local_signal(N=signal_length, A=amplitude, 
                              Fr=freq, phase=phase, S=periodic_start, 
                              L=periodic_length)
noise <- rnorm(n=signal_length, mean=0, sd=sigma)
x <- signal + noise 

## Plot what the local cosine signal 
plot(x, pch=19, cex=1.4, xlab="", ylab="Signal", 
     main="Local Cosine Signal plus Gaussian Noise")
lines(signal, lwd=2, col="red")
```

### The SWDFT
The cornerstone of this package is the `swdft::swdft` function. When I wrote this function, my goal was creating a function analagous to base R's `stats::fft` function for the time-frequency case. By this, I mean a simple, easy to use function, that provides the 2D SWDFT coefficients, and not a lot more. The `swdft::swdft` function is called with 

```{r}
window_size <- 32
a <- swdft::swdft(x=x, n=window_size)
```

The `swdft::swdft` function implements the SWDFT, which is defined by

$$
\begin{eqnarray}
  a_{k, p} &=& \sum_{j=0}^{n-1} x_{p-n+1+j} \omega_{n}^{-jk} \nonumber \\
  k &=& 0, 1, \ldots, N - 1 \nonumber \\
  p &=& n - 1, n, \ldots, N - 1.
\end{eqnarray}
$$

where $n$ is the window size, and $N$ is the signal length, and $\omega_n = \cos(\frac{2 \pi}{n}) + i \sin(\frac{2 \pi}{n})$. The SWDFT outputs a 2D $n \times P$ complex-valued array of coefficients, where the $n$ dimension corresponds to frequency, and the $P = N - n + 1$ dimension corresponds to window position. For visualization, covered in the next section, it is common to display the squared modulus of the SWDFT coefficients, which is defined by

$$
\begin{eqnarray}
  Mod(a_{k, p})^2 &=& Re(a_{k, p})^2 + Im(a_{k, p})^2
\end{eqnarray}
$$

In R, you can compute the modulus of a complex number with the `?Mod` function. 

The implementation of the SWDFT is straightforward, and can be understood by simply looking at the code:

```{r, eval=FALSE}
swdft_fft <- function(x, n, taper) {
  N <- length(x)
  P <- N - n + 1
  a <- array(data = NA, dim = c(n, P))

  for (p in n:N) {
    a[, p - n + 1] <- stats::fft(z = x[(p - n + 1):p] * taper)
  }

  return(a)
}
```

The actual implementation of the `swdft::swdft` function is a wrapper, which calls either `swdft_fftw` or `swdft_fft`, depending on if the `fftwtools` library is installed. The `fftwtools` package is an R-wrapper for the Fastest Fourier Transform in the West (FFTW) library, so it is much faster than base R's `fft` implementation.

The `swdft::swdft` function returns an S3 object of class `swdft`. This class includes the 2D complex array of SWDFT coefficients (`a$a`), along with basic information about the parameters used (see `?new_swdft` for more information). We provide a `plot.swdft` method that displays the squared modulus of SWDFT coefficients:

```{r}
plot(a)
```

In the next section, we detail the options available for customizing visualizations of the SWDFT. 

### Visualization
The default color used in `?plot.swdft` is grayscale. However, I often use the blue-to-red colorscale `tim.colors` from the `fields` package. You can replace the grayscale colorscale with `tim.colors` with the option `col="tim.colors"`:

```{r}
plot(a, col="tim.colors", title="SWDFT using the 'tim.colors' colorscale")
```

Often, we need to display the frequency dimension in different units, such as Hertz. For a SWDFT with length $n$ windows, the $k^{th}$ frequency can be interpreted as "$k$ complete cycles in a length $n$ period of time". Hence, the default in `plot.swdft` sets `freq_type="cycles"`, and using this option, the frequency dimension is indexed by the $k$ SWDFT coefficients. Another popular approach is Hertz, which can be used with the `freq_type="hertz"` option. If you use Hertz, you also need to specify the sampling frequency with the `fs=` option, for example:

```{r}
sampling_frequency <- 100
plot(a, freq_type="hertz", fs=sampling_frequency)
```

The option we provide for frequency units is `freq_type="fraction"`. In many fields, it is common to represent the frequency as the decimal value $\frac{k}{n}$, for $k=0, 1, \ldots, n-1$. This option is used in base R's plotting method for the `spectrum` function, `plot.spec`. An example of this option is given by:

```{r}
plot(a, freq_type="fraction")
```

When `freq_type="fraction"`, we follow the convention by only displaying the range from 0 to .5. This is a convention because for real-valued signals, the Fourier coefficients larger than .5 are equivalent to the complex conjugate of a Fourier coefficient less than .5. This implies that the values of their squared modulus is identical (this is why, in the previous plots, the frequencies on either side of a horizantal line are identical. Technically speaking, this phenomenon is called "aliasing"). 

Finally, you sometimes need to change either the axis labels or values. For example, maybe you want the x-axis to represent time, instead of the default "Window Position". You can change this using the `custom_xaxis=` option (there is a corresponding `custom_yaxis` as well). To use this option, you need to make sure that the length of the custom axis is the same as the dimension fo the `swdft` object (you can check this with `dim(a$a)`). 

```{r}
years <- 1900:1995
plot(a, freq_type="fraction", col="tim.colors", custom_xaxis=years, xlab="Years")
```

Those are the options I use most frequently. For details and more options, see the `?plot.swdft` documentation.

### Tapering and Smoothing
Discrete Fourier transform (DFT) coefficients are notoriously noisy. From a technical perspective, DFT coefficients do not provide a consistent estimate of the spectral density. Statisticians have solved this issue by either *tapering* the ends of the signal, or smoothing the DFT coefficients, and the `swdft` package provides options for both tapering and smoothing. 

For tapering, we provide the widely used cosine bell taper, based on R's `spec.taper` function. You can use this taper with the `taper_type="cosine"` option. In addition, you can specify the proportion of each end of the signal to taper with the `p=` option. An example of this is given by

```{r}
a_taper <- swdft::swdft(x=x, n=window_size, taper_type="cosine", p=.2)
plot(a_taper)
```

To smooth the SWDFT coefficients, we provide the `smooth=` option. This option builds a smoothing kernel using base R's `stats::kernel` function. The additional option `m=` controls the width of the kernel, and the option `num_convs=` specicies the number of times the kernel is convolved with itself. See `?stats::kernel` for more details. An example of smoothing the SWDFT coefficients is given by 

```{r}
a_smooth <- swdft::swdft(x=x, n=window_size, smooth="daniell", m=1, num_convs=0)
plot(a_smooth)
```

It is important to point out that the most widely used tapering approach is to use multiple tapers, which is often referred to as the *Multitaper* method. The `swdft` package does not provide an implementation of the multitaper method, but I would be willing to if there's significant interest. For an implementation, see the excellent `multitaper` R-package. 

## Cosine Regression
One of the most widely used models in statistical signal processing fits a cosine function to data, which we call *cosine regression*. Cosine regression is helpful for signals with obvious daily, weekly, or yearly trends that are stable over time. Formally, the cosine regression statistical model is given by 

$$
\begin{eqnarray}
  y_t &=& A \cos(2 \pi f t + \phi) + \epsilon_t \nonumber \\
  t &=& 0, 1, \ldots, N - 1.
\end{eqnarray}
$$

The cosine regression model has three parameters to estimate:

- A: Amplitude 
- f: Frequency 
- $\phi$: Phase 

There is a standard trick that uses trigonometric identities to "linearize" the cosine regression model in terms of amplitude and phase. After applying this trick, if the frequency parameter $f$ is known, you can estimate amplitude and phase with least squares. The `swdft::cosreg` function fits a the cosine regression model, given a frequency as input. For example, we can apply cosine regression to out local cosine signal generated above:

```{r}
cosreg_fit <- swdft::cosreg(x=x, f=freq)
plot(cosreg_fit)
```

We can check that the coefficients of the cosine regression model with 

```{r}
coefficients(cosreg_fit)
```

If you don't know which frequency to use, it is common to select it from the maximum of the periodogram, which can be done by:

```{r}
periodogram <- Mod(fft(x))^2
freqs <- (0:(length(x) - 1)) / length(x)
max_freq <- freqs[which.max(periodogram)]
cat("Estimated Frequency: ", max_freq, " True Frequency: ", freq, " \n")
```

### Local Cosine Regression 
For signals that are not periodic over the entire interval, such as the local cosine signal generated above, we provide the `swdft::local_cosreg` function. This function implements a fairly complicated maximum likelihood estimation procedure to estimate the parameters of the local cosine signal defined above:

```{r, cache=TRUE}
local_cosreg_fit <- swdft::local_cosreg(x=x)
plot(local_cosreg_fit)
coefficients(local_cosreg_fit)
```

Unfortunately, this function takes awhile to run, and should only be used for small signls (e.g. 100/200 data-points). Faster methods that work for more complicated signals, based on the method of _complex demodulation_, are covered in the next section. 

## Complex Demodulation
The third group of functions provided by the `swdft` package is based on the method complex demodulation. Complex demodulation can be seen as an estimator for the time-varying amplitude and phase of the following statistical model 

$$
\begin{eqnarray}
  y_t &=& A_t \cos(2 \pi f t + \phi_t) + \epsilon_t, \nonumber \\
  t &=& 0, 1, \ldots, N - 1.
\end{eqnarray}
$$
The only difference between this model and the cosine regression model is that the amplitude and phase parameters are now time-varying (e.g. $A \to A_t$, $\phi \to \phi_t$).

The `swdft` package provides two functions based on complex demodulation: `swdft::complex_demod`, and `swdft::matching_demod`. Since `swdft::matching_demod` repeatedly applies the `swdft::complex_demod` function, we introduce `swdft::complex_demod` first. 

Finally, since complex demodulation is useful for signals with time-varying parameters, we adapt the local cosine signal used in previous sections to have a time-varying amplitude, which is done with the following code:

```{r}
set.seed(666)

## Set the frequency and length of the signal 
N <- 128 
f0 <- 10/N

## Generate a time-varying amplitude 
amplitude <- rep(0, N)
inds11 <- 10:20
inds12 <- 21:50
inds13 <- 51:70
amplitude[inds11] <- seq(0, 1, length=length(inds11))
amplitude[inds12] <- seq(1, 1, length=length(inds12))
amplitude[inds13] <- seq(1, 0, length=length(inds13))

## Generate the cosine signal with time-varying amplitude plus noise
signal <- swdft::cosine(N=N, A=amplitude, Fr=f0, phase=0)
noise <- rnorm(n=N, mean=0, sd=sigma)
x_demod <- signal + noise

## Plot what the signal looks like 
plot(x_demod, pch=19, cex=1.4, main="Cosine signal with time-varying amplitude plus Gaussian noise", 
     xlab="", ylab="")
lines(signal, lwd=2, col="red")
```

### Complex Demodulation
Complex demodulation extracts a time-varying amplitude and phase from a signal. The method works in three steps

1. Demodulate the original series: $y_t = x_t \cdot e^{-2 \pi i f_0 t}$
2. Smooth the demodulated series: $z_t = \text{smooth}(y_t)$ using a low-pass filter 
3. Extract $A_t$ and $\phi_t$ from the smoothed, complex-valued signal $z_t$

So, to use the `swdft::complex_demod` function, you must provide two parameters:

1. The central frequency to demodulate ($f_0$)
2. The type of low-pass filter to use, and the parameters of that filter

We know the true frequency in our example, so that's what we use in this example. In some cases, you will know which frequency to use, for example, if your signal has daily, weekly, or monthly cycles. In other cases, users don't know which frequency to use, and want to estimate it from the data. The next function ``swdft::matching_demod``, provides an automatic method to select the frequency, which we describe in the next section. 

Regarding the low-pass filter, the `swdft::complex_demod` function provides three options: butterworth, moving average, and double moving average. It is important to note that step one of complex demodulation shifts the frequency of interest `f0` to zero, which means that all filters are relative to frequency 0. We use the butterworth filter as a default, which is specified with the `smooth="butterworth"` option. The default pass frequency for the butterworth filter is .1, specified by the `passfreq=.1` option. An example of `swdft::complex_demod` with the default parameters is given in the following code

```{r}
complex_demod_fit <- swdft::complex_demod(x=x_demod, f0=f0)
plot(complex_demod_fit)
lines(signal, col="blue")
legend("topright", col=c("black", "red", "blue"), 
       c("Signal+Noise", "Complex Demodulation", "True Signal"), lwd=1)
```

In the above example, complex demodulation captures the part of the signal with a time-varying amplitude, but overfits the ends. To get smoother estimates, we can reduce the pass frequency in the butterworth filter to .05 using the `passfreq=.05` option

```{r}
complex_demod_fit_smoother <- swdft::complex_demod(x=x_demod, f0=f0, passfreq=.05)
plot(complex_demod_fit_smoother)
lines(signal, col="blue")
legend("topright", col=c("black", "red", "blue"), 
       c("Signal+Noise", "Complex Demodulation", "True Signal"), lwd=1)
```


### Matching Demodulation
Imagine if a signal didn't have a single periodic component, but multiple. If this were true, then complex demodulation wouldn't be enough. To address this, the `swdft` provides the `swdft::matching_demod` function, which implements the matching demodulation algorithm. Matching demodulation can be seen as an estimator for the following statistical model of the sum of $R$ periodic signals with time-varying amplitudes and phases

$$
\begin{eqnarray}
    y_t &=& \sum_{r=1}^{R} A_{r, t} \cos(2 \pi f_r t + \phi_{r, t}) + \epsilon_t, \nonumber \\
    t &=& 0, 1, \ldots, N - 1.
\end{eqnarray}
$$


To demonstrate how `matching_demod` works, let's add a second signal with a time-varying ampltude to the example signal used in the previous section:

```{r}
## Generate the time-varying amplitude for the second periodic component 
amplitude2 <- rep(0, N)
inds21 <- 50:70
inds22 <- 71:100
inds23 <- 101:120
amplitude2[inds21] <- seq(0, 1, length=length(inds21))
amplitude2[inds22] <- seq(1, 1, length=length(inds22))
amplitude2[inds23] <- seq(1, 0, length=length(inds23))

## Set the frequency for the second periodic component
f1 <- 30 / N

## Generate the second signal and add it to the first 
signal2 <- swdft::cosine(N=N, A=amplitude2, Fr=f1, phase=phase)
x_demod <- x_demod + signal2

## Plot what the two signals plus noise look like
plot(x_demod, pch=19, cex=1, main="Two cosine signals with time-varying amplitudes plus noise", 
     xlab="")
lines(signal, col="red", lwd=2)
lines(signal2, col="blue", lwd=2)
```

Matching demodulation is a greedy algorithm that repeatedly applies complex demodulation to a signal until no large SWDFT coefficients remain. Each iteration of matching demodulation has the following three steps

1. Find the largest SWDFT coefficient, and check if it is larger than a threshold. If it's not, stop. If it is, continue to step two. 
2. Apply complex-demodulation at the frequency of the SWDFT coefficient from step one 
3. Remove fitted valued from the complex demodulated model from step two, and return to step one with the residuals. 

Matching demodulation requires a few more parameters than complex demodulation. First, because matching demodulation selects the frequency to demodulate with the largest SWDFT coefficient, we need to provide a window size for the SWDFT. Next, we need to set the threshold for "how large" a SWDFT coefficient must be for the algorithm to keep iterating. I currently set these parameters through trial-and-error for a particular applications, but more research in understanding these choices would be valuable. For signals standardized to have mean zero and standard deviation one, a threshold between .03 to .05 has worked well. Therefore, we set the default threshold with `thresh=.05`. With this in mind, you can apply the matching demodulation algorithm as follows:

```{r}
matching_demod_fit <- swdft::matching_demod(x=x_demod, n=70)
plot(matching_demod_fit)
```

The fit looks great, but how does it work? To better understand matching demodulation, we can analyze the `matching_demod_fit` object. This object is an an S3 object with class `swdft_matching_demod`. The first thing we can do is show the fitted values from complex demodulation in each iteration, which can be accessed with `matching_demod_fit$iterations$iterfits`:

```{r}
plot(x_demod, cex=1, pch=19, ylim=c(-2, 3), xlab="", ylab="", 
     main="Fitted values from each iteration of matching demodulation")
lines(signal, col="red")
lines(signal2, col="blue")

lines(matching_demod_fit$iterations$iter_fits[1, ], col="green", lwd=2, lty=2)
lines(matching_demod_fit$iterations$iter_fits[2, ], col="purple", lwd=2, lty=2)

legend("topright", c("Signal + Noise", "Signal 1", "Signal 2", "Iteration 1", "Iteration 2"), 
       col=c("black", "red", "blue", "green", "purple"), lwd=2, cex=.8)
```

This shows that matching demodulation applies complex demodulation to the second signal (`signal2` in the code chunk above) in the first iteration, and applies complex demodulation to the first signal (`signal` above) in the second iteration. And that's great, because it implies that the matching demodulation algorithm recovers the true data generating process. 

Another useful visualization is the estimated coefficients from the $R$ local time-varying cosines model, presented at the beginning of this section. We can access the coefficients with `matching_demod_fit$coefficients`. For example, we can visualize the time-varying amplitude in each iteration of the algorithm:

```{r}
plot(matching_demod_fit$coefficients$inst_amp[1, ], type="l", lwd=2, col="red", ylim=c(0, 1.5), 
     main="Time-varying amplitude for matching demodulation iterations", xlab="", ylab="")
lines(matching_demod_fit$coefficients$inst_amp[2, ], lwd=2, col="blue")
legend("topright", col=c("red", "blue"), lwd=2, 
       paste0("Iteration ", 1:2, ", Frequency: ", round(matching_demod_fit$coefficients$f0, digits=3)))
```

This shows that in the first iteration, frequency $\approx .22$ has large ampltitude near the end of the signal, and in the second iteration, frequency $\approx .07$ has large amplitude in the beginning of the signal.
